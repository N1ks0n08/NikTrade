// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BINANCEKLINE_BINANCE_H_
#define FLATBUFFERS_GENERATED_BINANCEKLINE_BINANCE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace Binance {

struct Kline;
struct KlineBuilder;

struct Klines;
struct KlinesBuilder;

struct Kline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KlineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPEN_TIME = 4,
    VT_OPEN_PRICE = 6,
    VT_HIGH_PRICE = 8,
    VT_LOW_PRICE = 10,
    VT_CLOSE_PRICE = 12,
    VT_VOLUME = 14,
    VT_CLOSE_TIME = 16,
    VT_QUOTE_ASSET_VOLUME = 18,
    VT_NUMBER_OF_TRADES = 20,
    VT_TAKER_BUY_BASE = 22,
    VT_TAKER_BUY_QUOTE = 24,
    VT_IGNORE = 26
  };
  uint64_t open_time() const {
    return GetField<uint64_t>(VT_OPEN_TIME, 0);
  }
  const ::flatbuffers::String *open_price() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPEN_PRICE);
  }
  const ::flatbuffers::String *high_price() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HIGH_PRICE);
  }
  const ::flatbuffers::String *low_price() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOW_PRICE);
  }
  const ::flatbuffers::String *close_price() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLOSE_PRICE);
  }
  const ::flatbuffers::String *volume() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOLUME);
  }
  uint64_t close_time() const {
    return GetField<uint64_t>(VT_CLOSE_TIME, 0);
  }
  const ::flatbuffers::String *quote_asset_volume() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUOTE_ASSET_VOLUME);
  }
  uint64_t number_of_trades() const {
    return GetField<uint64_t>(VT_NUMBER_OF_TRADES, 0);
  }
  const ::flatbuffers::String *taker_buy_base() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAKER_BUY_BASE);
  }
  const ::flatbuffers::String *taker_buy_quote() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAKER_BUY_QUOTE);
  }
  const ::flatbuffers::String *ignore() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IGNORE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OPEN_TIME, 8) &&
           VerifyOffset(verifier, VT_OPEN_PRICE) &&
           verifier.VerifyString(open_price()) &&
           VerifyOffset(verifier, VT_HIGH_PRICE) &&
           verifier.VerifyString(high_price()) &&
           VerifyOffset(verifier, VT_LOW_PRICE) &&
           verifier.VerifyString(low_price()) &&
           VerifyOffset(verifier, VT_CLOSE_PRICE) &&
           verifier.VerifyString(close_price()) &&
           VerifyOffset(verifier, VT_VOLUME) &&
           verifier.VerifyString(volume()) &&
           VerifyField<uint64_t>(verifier, VT_CLOSE_TIME, 8) &&
           VerifyOffset(verifier, VT_QUOTE_ASSET_VOLUME) &&
           verifier.VerifyString(quote_asset_volume()) &&
           VerifyField<uint64_t>(verifier, VT_NUMBER_OF_TRADES, 8) &&
           VerifyOffset(verifier, VT_TAKER_BUY_BASE) &&
           verifier.VerifyString(taker_buy_base()) &&
           VerifyOffset(verifier, VT_TAKER_BUY_QUOTE) &&
           verifier.VerifyString(taker_buy_quote()) &&
           VerifyOffset(verifier, VT_IGNORE) &&
           verifier.VerifyString(ignore()) &&
           verifier.EndTable();
  }
};

struct KlineBuilder {
  typedef Kline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_open_time(uint64_t open_time) {
    fbb_.AddElement<uint64_t>(Kline::VT_OPEN_TIME, open_time, 0);
  }
  void add_open_price(::flatbuffers::Offset<::flatbuffers::String> open_price) {
    fbb_.AddOffset(Kline::VT_OPEN_PRICE, open_price);
  }
  void add_high_price(::flatbuffers::Offset<::flatbuffers::String> high_price) {
    fbb_.AddOffset(Kline::VT_HIGH_PRICE, high_price);
  }
  void add_low_price(::flatbuffers::Offset<::flatbuffers::String> low_price) {
    fbb_.AddOffset(Kline::VT_LOW_PRICE, low_price);
  }
  void add_close_price(::flatbuffers::Offset<::flatbuffers::String> close_price) {
    fbb_.AddOffset(Kline::VT_CLOSE_PRICE, close_price);
  }
  void add_volume(::flatbuffers::Offset<::flatbuffers::String> volume) {
    fbb_.AddOffset(Kline::VT_VOLUME, volume);
  }
  void add_close_time(uint64_t close_time) {
    fbb_.AddElement<uint64_t>(Kline::VT_CLOSE_TIME, close_time, 0);
  }
  void add_quote_asset_volume(::flatbuffers::Offset<::flatbuffers::String> quote_asset_volume) {
    fbb_.AddOffset(Kline::VT_QUOTE_ASSET_VOLUME, quote_asset_volume);
  }
  void add_number_of_trades(uint64_t number_of_trades) {
    fbb_.AddElement<uint64_t>(Kline::VT_NUMBER_OF_TRADES, number_of_trades, 0);
  }
  void add_taker_buy_base(::flatbuffers::Offset<::flatbuffers::String> taker_buy_base) {
    fbb_.AddOffset(Kline::VT_TAKER_BUY_BASE, taker_buy_base);
  }
  void add_taker_buy_quote(::flatbuffers::Offset<::flatbuffers::String> taker_buy_quote) {
    fbb_.AddOffset(Kline::VT_TAKER_BUY_QUOTE, taker_buy_quote);
  }
  void add_ignore(::flatbuffers::Offset<::flatbuffers::String> ignore) {
    fbb_.AddOffset(Kline::VT_IGNORE, ignore);
  }
  explicit KlineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Kline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Kline>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Kline> CreateKline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t open_time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> open_price = 0,
    ::flatbuffers::Offset<::flatbuffers::String> high_price = 0,
    ::flatbuffers::Offset<::flatbuffers::String> low_price = 0,
    ::flatbuffers::Offset<::flatbuffers::String> close_price = 0,
    ::flatbuffers::Offset<::flatbuffers::String> volume = 0,
    uint64_t close_time = 0,
    ::flatbuffers::Offset<::flatbuffers::String> quote_asset_volume = 0,
    uint64_t number_of_trades = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taker_buy_base = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taker_buy_quote = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ignore = 0) {
  KlineBuilder builder_(_fbb);
  builder_.add_number_of_trades(number_of_trades);
  builder_.add_close_time(close_time);
  builder_.add_open_time(open_time);
  builder_.add_ignore(ignore);
  builder_.add_taker_buy_quote(taker_buy_quote);
  builder_.add_taker_buy_base(taker_buy_base);
  builder_.add_quote_asset_volume(quote_asset_volume);
  builder_.add_volume(volume);
  builder_.add_close_price(close_price);
  builder_.add_low_price(low_price);
  builder_.add_high_price(high_price);
  builder_.add_open_price(open_price);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Kline> CreateKlineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t open_time = 0,
    const char *open_price = nullptr,
    const char *high_price = nullptr,
    const char *low_price = nullptr,
    const char *close_price = nullptr,
    const char *volume = nullptr,
    uint64_t close_time = 0,
    const char *quote_asset_volume = nullptr,
    uint64_t number_of_trades = 0,
    const char *taker_buy_base = nullptr,
    const char *taker_buy_quote = nullptr,
    const char *ignore = nullptr) {
  auto open_price__ = open_price ? _fbb.CreateString(open_price) : 0;
  auto high_price__ = high_price ? _fbb.CreateString(high_price) : 0;
  auto low_price__ = low_price ? _fbb.CreateString(low_price) : 0;
  auto close_price__ = close_price ? _fbb.CreateString(close_price) : 0;
  auto volume__ = volume ? _fbb.CreateString(volume) : 0;
  auto quote_asset_volume__ = quote_asset_volume ? _fbb.CreateString(quote_asset_volume) : 0;
  auto taker_buy_base__ = taker_buy_base ? _fbb.CreateString(taker_buy_base) : 0;
  auto taker_buy_quote__ = taker_buy_quote ? _fbb.CreateString(taker_buy_quote) : 0;
  auto ignore__ = ignore ? _fbb.CreateString(ignore) : 0;
  return Binance::CreateKline(
      _fbb,
      open_time,
      open_price__,
      high_price__,
      low_price__,
      close_price__,
      volume__,
      close_time,
      quote_asset_volume__,
      number_of_trades,
      taker_buy_base__,
      taker_buy_quote__,
      ignore__);
}

struct Klines FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KlinesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KLINES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Binance::Kline>> *klines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Binance::Kline>> *>(VT_KLINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KLINES) &&
           verifier.VerifyVector(klines()) &&
           verifier.VerifyVectorOfTables(klines()) &&
           verifier.EndTable();
  }
};

struct KlinesBuilder {
  typedef Klines Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_klines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Binance::Kline>>> klines) {
    fbb_.AddOffset(Klines::VT_KLINES, klines);
  }
  explicit KlinesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Klines> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Klines>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Klines> CreateKlines(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Binance::Kline>>> klines = 0) {
  KlinesBuilder builder_(_fbb);
  builder_.add_klines(klines);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Klines> CreateKlinesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Binance::Kline>> *klines = nullptr) {
  auto klines__ = klines ? _fbb.CreateVector<::flatbuffers::Offset<Binance::Kline>>(*klines) : 0;
  return Binance::CreateKlines(
      _fbb,
      klines__);
}

inline const Binance::Klines *GetKlines(const void *buf) {
  return ::flatbuffers::GetRoot<Binance::Klines>(buf);
}

inline const Binance::Klines *GetSizePrefixedKlines(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Binance::Klines>(buf);
}

inline bool VerifyKlinesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Binance::Klines>(nullptr);
}

inline bool VerifySizePrefixedKlinesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Binance::Klines>(nullptr);
}

inline void FinishKlinesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Binance::Klines> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedKlinesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Binance::Klines> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Binance

#endif  // FLATBUFFERS_GENERATED_BINANCEKLINE_BINANCE_H_

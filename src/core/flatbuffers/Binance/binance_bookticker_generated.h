// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BINANCEBOOKTICKER_BINANCE_H_
#define FLATBUFFERS_GENERATED_BINANCEBOOKTICKER_BINANCE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace Binance {

struct BookTicker;
struct BookTickerBuilder;

struct BookTicker FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BookTickerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPDATE_ID = 4,
    VT_SYMBOL = 6,
    VT_BEST_BID = 8,
    VT_BID_QTY = 10,
    VT_BEST_ASK = 12,
    VT_ASK_QTY = 14
  };
  uint64_t update_id() const {
    return GetField<uint64_t>(VT_UPDATE_ID, 0);
  }
  const ::flatbuffers::String *symbol() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  const ::flatbuffers::String *best_bid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BEST_BID);
  }
  const ::flatbuffers::String *bid_qty() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BID_QTY);
  }
  const ::flatbuffers::String *best_ask() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BEST_ASK);
  }
  const ::flatbuffers::String *ask_qty() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ASK_QTY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UPDATE_ID, 8) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyOffset(verifier, VT_BEST_BID) &&
           verifier.VerifyString(best_bid()) &&
           VerifyOffset(verifier, VT_BID_QTY) &&
           verifier.VerifyString(bid_qty()) &&
           VerifyOffset(verifier, VT_BEST_ASK) &&
           verifier.VerifyString(best_ask()) &&
           VerifyOffset(verifier, VT_ASK_QTY) &&
           verifier.VerifyString(ask_qty()) &&
           verifier.EndTable();
  }
};

struct BookTickerBuilder {
  typedef BookTicker Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_update_id(uint64_t update_id) {
    fbb_.AddElement<uint64_t>(BookTicker::VT_UPDATE_ID, update_id, 0);
  }
  void add_symbol(::flatbuffers::Offset<::flatbuffers::String> symbol) {
    fbb_.AddOffset(BookTicker::VT_SYMBOL, symbol);
  }
  void add_best_bid(::flatbuffers::Offset<::flatbuffers::String> best_bid) {
    fbb_.AddOffset(BookTicker::VT_BEST_BID, best_bid);
  }
  void add_bid_qty(::flatbuffers::Offset<::flatbuffers::String> bid_qty) {
    fbb_.AddOffset(BookTicker::VT_BID_QTY, bid_qty);
  }
  void add_best_ask(::flatbuffers::Offset<::flatbuffers::String> best_ask) {
    fbb_.AddOffset(BookTicker::VT_BEST_ASK, best_ask);
  }
  void add_ask_qty(::flatbuffers::Offset<::flatbuffers::String> ask_qty) {
    fbb_.AddOffset(BookTicker::VT_ASK_QTY, ask_qty);
  }
  explicit BookTickerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BookTicker> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BookTicker>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BookTicker> CreateBookTicker(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t update_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol = 0,
    ::flatbuffers::Offset<::flatbuffers::String> best_bid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> bid_qty = 0,
    ::flatbuffers::Offset<::flatbuffers::String> best_ask = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ask_qty = 0) {
  BookTickerBuilder builder_(_fbb);
  builder_.add_update_id(update_id);
  builder_.add_ask_qty(ask_qty);
  builder_.add_best_ask(best_ask);
  builder_.add_bid_qty(bid_qty);
  builder_.add_best_bid(best_bid);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BookTicker> CreateBookTickerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t update_id = 0,
    const char *symbol = nullptr,
    const char *best_bid = nullptr,
    const char *bid_qty = nullptr,
    const char *best_ask = nullptr,
    const char *ask_qty = nullptr) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto best_bid__ = best_bid ? _fbb.CreateString(best_bid) : 0;
  auto bid_qty__ = bid_qty ? _fbb.CreateString(bid_qty) : 0;
  auto best_ask__ = best_ask ? _fbb.CreateString(best_ask) : 0;
  auto ask_qty__ = ask_qty ? _fbb.CreateString(ask_qty) : 0;
  return Binance::CreateBookTicker(
      _fbb,
      update_id,
      symbol__,
      best_bid__,
      bid_qty__,
      best_ask__,
      ask_qty__);
}

inline const Binance::BookTicker *GetBookTicker(const void *buf) {
  return ::flatbuffers::GetRoot<Binance::BookTicker>(buf);
}

inline const Binance::BookTicker *GetSizePrefixedBookTicker(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Binance::BookTicker>(buf);
}

inline bool VerifyBookTickerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Binance::BookTicker>(nullptr);
}

inline bool VerifySizePrefixedBookTickerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Binance::BookTicker>(nullptr);
}

inline void FinishBookTickerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Binance::BookTicker> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBookTickerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Binance::BookTicker> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Binance

#endif  // FLATBUFFERS_GENERATED_BINANCEBOOKTICKER_BINANCE_H_
